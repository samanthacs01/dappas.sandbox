// Code generated by mockery v2.52.1. DO NOT EDIT.

package mocks

import (
	mock "github.com/stretchr/testify/mock"
	receivables "selector.dev/pulse/internal/domain/receivables"
)

// IInvoicesRepository is an autogenerated mock type for the IInvoicesRepository type
type IInvoicesRepository struct {
	mock.Mock
}

// AcceptGeneratedBills provides a mock function with given fields: ids
func (_m *IInvoicesRepository) AcceptGeneratedBills(ids []int) error {
	ret := _m.Called(ids)

	if len(ret) == 0 {
		panic("no return value specified for AcceptGeneratedBills")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func([]int) error); ok {
		r0 = rf(ids)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FindAllInvoices provides a mock function with given fields: criteria
func (_m *IInvoicesRepository) FindAllInvoices(criteria receivables.InvoiceListFilter) (*[]receivables.InvoiceListItem, *int64, error) {
	ret := _m.Called(criteria)

	if len(ret) == 0 {
		panic("no return value specified for FindAllInvoices")
	}

	var r0 *[]receivables.InvoiceListItem
	var r1 *int64
	var r2 error
	if rf, ok := ret.Get(0).(func(receivables.InvoiceListFilter) (*[]receivables.InvoiceListItem, *int64, error)); ok {
		return rf(criteria)
	}
	if rf, ok := ret.Get(0).(func(receivables.InvoiceListFilter) *[]receivables.InvoiceListItem); ok {
		r0 = rf(criteria)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*[]receivables.InvoiceListItem)
		}
	}

	if rf, ok := ret.Get(1).(func(receivables.InvoiceListFilter) *int64); ok {
		r1 = rf(criteria)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*int64)
		}
	}

	if rf, ok := ret.Get(2).(func(receivables.InvoiceListFilter) error); ok {
		r2 = rf(criteria)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GeneratedInvoices provides a mock function with given fields: flights
func (_m *IInvoicesRepository) GeneratedInvoices(flights []int) (*[]receivables.DraftInvoice, error) {
	ret := _m.Called(flights)

	if len(ret) == 0 {
		panic("no return value specified for GeneratedInvoices")
	}

	var r0 *[]receivables.DraftInvoice
	var r1 error
	if rf, ok := ret.Get(0).(func([]int) (*[]receivables.DraftInvoice, error)); ok {
		return rf(flights)
	}
	if rf, ok := ret.Get(0).(func([]int) *[]receivables.DraftInvoice); ok {
		r0 = rf(flights)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*[]receivables.DraftInvoice)
		}
	}

	if rf, ok := ret.Get(1).(func([]int) error); ok {
		r1 = rf(flights)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCollectionRateValues provides a mock function with given fields: start, end
func (_m *IInvoicesRepository) GetCollectionRateValues(start string, end string) (*[]receivables.ReceivableKpiDetailsItem, error) {
	ret := _m.Called(start, end)

	if len(ret) == 0 {
		panic("no return value specified for GetCollectionRateValues")
	}

	var r0 *[]receivables.ReceivableKpiDetailsItem
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string) (*[]receivables.ReceivableKpiDetailsItem, error)); ok {
		return rf(start, end)
	}
	if rf, ok := ret.Get(0).(func(string, string) *[]receivables.ReceivableKpiDetailsItem); ok {
		r0 = rf(start, end)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*[]receivables.ReceivableKpiDetailsItem)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(start, end)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCollectionWithPaymentTermsValues provides a mock function with given fields: start, end
func (_m *IInvoicesRepository) GetCollectionWithPaymentTermsValues(start string, end string) (*[]receivables.ReceivableKpiDetailsItem, error) {
	ret := _m.Called(start, end)

	if len(ret) == 0 {
		panic("no return value specified for GetCollectionWithPaymentTermsValues")
	}

	var r0 *[]receivables.ReceivableKpiDetailsItem
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string) (*[]receivables.ReceivableKpiDetailsItem, error)); ok {
		return rf(start, end)
	}
	if rf, ok := ret.Get(0).(func(string, string) *[]receivables.ReceivableKpiDetailsItem); ok {
		r0 = rf(start, end)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*[]receivables.ReceivableKpiDetailsItem)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(start, end)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCustomerConcentrationValues provides a mock function with given fields: start, end
func (_m *IInvoicesRepository) GetCustomerConcentrationValues(start string, end string) (*[]receivables.ReceivableKpiDetailsItem, error) {
	ret := _m.Called(start, end)

	if len(ret) == 0 {
		panic("no return value specified for GetCustomerConcentrationValues")
	}

	var r0 *[]receivables.ReceivableKpiDetailsItem
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string) (*[]receivables.ReceivableKpiDetailsItem, error)); ok {
		return rf(start, end)
	}
	if rf, ok := ret.Get(0).(func(string, string) *[]receivables.ReceivableKpiDetailsItem); ok {
		r0 = rf(start, end)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*[]receivables.ReceivableKpiDetailsItem)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(start, end)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetReceivableStatsKpi provides a mock function with given fields: start, end
func (_m *IInvoicesRepository) GetReceivableStatsKpi(start string, end string) (*receivables.ReceivableStats, error) {
	ret := _m.Called(start, end)

	if len(ret) == 0 {
		panic("no return value specified for GetReceivableStatsKpi")
	}

	var r0 *receivables.ReceivableStats
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string) (*receivables.ReceivableStats, error)); ok {
		return rf(start, end)
	}
	if rf, ok := ret.Get(0).(func(string, string) *receivables.ReceivableStats); ok {
		r0 = rf(start, end)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*receivables.ReceivableStats)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(start, end)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTotalOutstandingValues provides a mock function with given fields: start, end
func (_m *IInvoicesRepository) GetTotalOutstandingValues(start string, end string) (*[]receivables.ReceivableKpiDetailsItem, error) {
	ret := _m.Called(start, end)

	if len(ret) == 0 {
		panic("no return value specified for GetTotalOutstandingValues")
	}

	var r0 *[]receivables.ReceivableKpiDetailsItem
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string) (*[]receivables.ReceivableKpiDetailsItem, error)); ok {
		return rf(start, end)
	}
	if rf, ok := ret.Get(0).(func(string, string) *[]receivables.ReceivableKpiDetailsItem); ok {
		r0 = rf(start, end)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*[]receivables.ReceivableKpiDetailsItem)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(start, end)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTotalOverdueValues provides a mock function with given fields: start, end
func (_m *IInvoicesRepository) GetTotalOverdueValues(start string, end string) (*[]map[string]interface{}, error) {
	ret := _m.Called(start, end)

	if len(ret) == 0 {
		panic("no return value specified for GetTotalOverdueValues")
	}

	var r0 *[]map[string]interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string) (*[]map[string]interface{}, error)); ok {
		return rf(start, end)
	}
	if rf, ok := ret.Get(0).(func(string, string) *[]map[string]interface{}); ok {
		r0 = rf(start, end)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*[]map[string]interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(start, end)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RegisterPayment provides a mock function with given fields: id, amount
func (_m *IInvoicesRepository) RegisterPayment(id int, amount float64) error {
	ret := _m.Called(id, amount)

	if len(ret) == 0 {
		panic("no return value specified for RegisterPayment")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(int, float64) error); ok {
		r0 = rf(id, amount)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NewIInvoicesRepository creates a new instance of IInvoicesRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIInvoicesRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *IInvoicesRepository {
	mock := &IInvoicesRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
